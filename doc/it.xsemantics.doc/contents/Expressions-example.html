<!--
Copyright (c) 2013-2017 Lorenzo Bettini.
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
  Lorenzo Bettini - Initial contribution and API
-->

<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>An Expression Language</title>

<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="00-Main.html" title="">
</head>
<body>
<a name="Expressions"></a>
<h1>An Expression Language</h1>
<p>
Let us consider this Xtext implementation of an Expressions language
(similar to the <em>Arithmetic</em> example shipped with Xtext)
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;it.xsemantics.example.expressions.Expressions&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.common.Terminals<br/>
<br/>
<span class="keyword">generate</span>&nbsp;expressions&nbsp;<span class="string">"http://xsemantics.sf.net/example/expressions/Expressions"</span><br/>
<br/>
Model:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(variables+=Variable)*<br/>
;<br/>
<br/>
Variable:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;name=ID&nbsp;<span class="string">&apos;=&apos;</span>&nbsp;expression=Expression<br/>
;<br/>
<br/>
Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BooleanExpression;<br/>
<br/>
BooleanExpression&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Comparison&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(({AndOrExpression.left=<span class="keyword">current</span>}&nbsp;op=(<span class="string">"||"</span>|<span class="string">"&amp;&amp;"</span>))&nbsp;right=Comparison)*;<br/>
<br/>
Comparison&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(({Comparison.left=<span class="keyword">current</span>}&nbsp;op=(<span class="string">"&lt;"</span>)&nbsp;)&nbsp;right=Equals)*;<br/>
<br/>
Equals&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Addition&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(({Equals.left=<span class="keyword">current</span>}&nbsp;op=(<span class="string">"=="</span>)&nbsp;)&nbsp;right=Addition)*;<br/>
&nbsp;<br/>
Addition&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Multiplication<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(({Plus.left=<span class="keyword">current</span>}&nbsp;<span class="string">&apos;+&apos;</span>&nbsp;|&nbsp;{Minus.left=<span class="keyword">current</span>}&nbsp;<span class="string">&apos;-&apos;</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right=Multiplication)*;&nbsp;<br/>
<br/>
Multiplication&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Prefixed&nbsp;(({MultiOrDiv.left=<span class="keyword">current</span>}&nbsp;op=(<span class="string">"*"</span>|<span class="string">"/"</span>))&nbsp;right=Prefixed)*;<br/>
<br/>
Prefixed&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{BooleanNegation}&nbsp;=&gt;<span class="string">"!"</span>&nbsp;expression=Atomic&nbsp;|&nbsp;<span class="comment">/*&nbsp;right&nbsp;associativity&nbsp;*/</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ArithmeticSigned}&nbsp;=&gt;<span class="string">"-"</span>&nbsp;expression=Atomic&nbsp;|&nbsp;<span class="comment">/*&nbsp;right&nbsp;associativity&nbsp;*/</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Atomic;<br/>
<br/>
Atomic&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;Expression&nbsp;<span class="string">&apos;)&apos;</span>&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{NumberLiteral}&nbsp;value=INT&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{StringLiteral}&nbsp;value=STRING&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{BooleanLiteral}&nbsp;value=(<span class="string">&apos;true&apos;</span>|<span class="string">&apos;false&apos;</span>)&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{VariableReference}&nbsp;ref=[Variable]<br/>
;<br/>
<br/>
<span class="comment">//&nbsp;the&nbsp;types&nbsp;will&nbsp;be&nbsp;used&nbsp;only&nbsp;internally&nbsp;by&nbsp;the&nbsp;type&nbsp;system<br/>
</span>Type:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{IntType}&nbsp;<span class="string">&apos;int&apos;</span>&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{StringType}&nbsp;<span class="string">&apos;string&apos;</span>&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{BooleanType}&nbsp;<span class="string">&apos;boolean&apos;</span><br/>
;<br/>
</p>
</div>
</div>
</p>
<p>
With this language you can write variable declarations assigning an
expression (you don&apos;t declare variable types); expressions can refer to
variables declared before the current variable (the scoping will take care of
this).
</p>
<p>
Note that, for the sake of simplicity, we do not consider a full
expression grammar, for instance, we only consider <span class="inlinecode">&lt;</span> as a comparison
operator.  This is just to keep this example simple and concentrate
on writing a type system and an interpreter with Xsemantics.
</p>
<p>
Now we would like to implement these checks:
</p>
<p>
<ul>
	<li>
		<span class="inlinecode">-&nbsp;/&nbsp;*</span> binary operators and <span class="inlinecode">-</span> unary operator
		act only on numeric expressions
	</li>
	<li>
		<span class="inlinecode">+</span> can act both on numeric expressions and on strings; if one
		of the operand is a string the whole expression will be a string
	</li>
	<li>
		<span class="inlinecode">==</span> operator acts only on expressions of the same type
	</li>
	<li>
		<span class="inlinecode">&lt;</span> operator acts only on numeric and string expressions,
		and the two subexpressions must be of the same type
	</li>
	<li>
		<span class="inlinecode">&amp;&amp;&nbsp;||</span> binary operators and <span class="inlinecode">!</span> unary operator
		act only on boolean expressions
	</li>
</ul>
</p>
<p>
So let&apos;s start writing the static semantics for the expressions language,
i.e., the type system.
</p>
<p>
Note that in the grammar we also have a definition for <span class="inlinecode">Type</span>, though
that rule will never be used in the grammar; we chose this way so that
we will have also the EClass definitions for the types that will be used
by the type system.  Of course, you could have simply define the hierarchy
for types using plain Java.
</p>
<a name="ExpressionsTS"></a>
<h2>Expressions Type System</h2>
<p>
Since we will extend the semantics of this language, we will start with
a first implementation.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">system</span>&nbsp;<span class="keyword">it</span>.xsemantics.example.expressions.typing.ExpressionsSemantics<br/>
<br/>
<span class="keyword">validatorExtends</span>&nbsp;<span class="keyword">it</span>.xsemantics.example.expressions.validation.AbstractExpressionsJavaValidator<br/>
<br/>
<span class="keyword">import</span>&nbsp;<span class="keyword">it</span>.xsemantics.example.expressions.expressions.*<br/>
<br/>
<span class="keyword">judgments</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;|-&nbsp;Expression&nbsp;expression&nbsp;:&nbsp;<span class="keyword">output</span>&nbsp;Type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"cannot&nbsp;type&nbsp;"</span>&nbsp;+&nbsp;stringRep(expression)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;expression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;more&nbsp;judgments&nbsp;later<br/>
</span>}<br/>
</p>
</div>
</div>
</p>
<p>
So we define a judgment that we call <span class="inlinecode">type</span> which takes an
<span class="inlinecode">Expression</span> as input parameter and provides a <span class="inlinecode">Type</span> as
output.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">axiom</span>&nbsp;NumeralLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;NumberLiteral&nbsp;num&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExpressionsFactory::eINSTANCE.createIntType<br/>
<br/>
<span class="keyword">axiom</span>&nbsp;BooleanLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;BooleanLiteral&nbsp;bool&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExpressionsFactory::eINSTANCE.createBooleanType<br/>
<br/>
<span class="keyword">axiom</span>&nbsp;StringLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;StringLiteral&nbsp;str&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExpressionsFactory::eINSTANCE.createStringType<br/>
</p>
</div>
</div>
</p>
<p>
For the constants, we can write axioms, which will simply return
an instance of the corresponding type.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;MultiOrDiv<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;MultiOrDiv&nbsp;multiOrDiv&nbsp;:&nbsp;IntType&nbsp;intType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;multiOrDiv.left&nbsp;:&nbsp;intType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;multiOrDiv.right&nbsp;:&nbsp;intType<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;Minus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Minus&nbsp;minus&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExpressionsFactory::eINSTANCE.createIntType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;IntType&nbsp;intType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;minus.left&nbsp;:&nbsp;intType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;minus.right&nbsp;:&nbsp;intType<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The rules for multiplication, division and minus are similar (we do not
have a base class for them all, so we need two rules); they both state
that the result type is an <span class="inlinecode">IntType</span>, provided that the subexpressions
have themselves an an <span class="inlinecode">IntType</span>.  They do this in two different
(equivalent) ways.
</p>
<p>
The first one states that the result is an <span class="inlinecode">IntType</span> which is the
result of the typing of the left and right subexpressions.  Remember
that for this judgment, the second parameter is an output parameter.
Basically, the second rule does the same, in a more explicit way, and
it does not bind the output result (which is created on the fly) to
the result of typing of the subexpressions (which, however, are
still required to have integer type, since we pass to the rule invocation
an <span class="inlinecode">IntType</span> as output argument).
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;Plus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Plus&nbsp;plus&nbsp;:&nbsp;Type&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.left&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;leftType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.right&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;rightType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType&nbsp;||&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createStringType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType&nbsp;&amp;&amp;&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;leftType&nbsp;<span class="comment">//&nbsp;i.e.,&nbsp;IntType<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Remember that for the + operator we are willing to deal both
with strings (string concatenation) and with integers (standard arithmetic
sum); but, if one of the two subexpressions has <span class="inlinecode">StringType</span>
then we consider the whole plus expression as a string concatenation
and we give it type string.  From the premises, it should be clear
that, in case one of the subexpressions has boolean type, the
rule will fail.
</p>
<p>
Note that we use the operator <span class="inlinecode">or</span>, <a href="XsemanticsSyntax.html#Premises" title="Go to &quot;Premises&quot;">Section about premises</a>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;Comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Comparison&nbsp;comparison&nbsp;:&nbsp;ExpressionsFactory::eINSTANCE.createBooleanType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;|-&nbsp;comparison.left&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;leftType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;|-&nbsp;comparison.right&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;rightType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;cannot&nbsp;compare&nbsp;booleans<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType&nbsp;&amp;&amp;&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType)&nbsp;||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType&nbsp;&amp;&amp;&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType)<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;Equals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Equals&nbsp;comparison&nbsp;:&nbsp;ExpressionsFactory::eINSTANCE.createBooleanType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;comparison.left&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;leftType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;comparison.right&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;rightType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;can&nbsp;compare&nbsp;only&nbsp;if&nbsp;they&nbsp;have&nbsp;the&nbsp;same&nbsp;type<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;(leftType.eClass&nbsp;==&nbsp;rightType.eClass)<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The code for <span class="inlinecode">Comparison</span> and <span class="inlinecode">Equals</span> are similar: they both
return a boolean type as a result; but while equality can be checked
with any type of expressions (provided the subexpressions have the
same type), the comparison (which, in our example, limits to
<span class="inlinecode">&lt;</span>) does not consider boolean subexpressions.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;BooleanNegation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;BooleanNegation&nbsp;negation&nbsp;:&nbsp;BooleanType&nbsp;boolType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;negation.expression&nbsp;:&nbsp;boolType<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;AndOr<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;AndOrExpression&nbsp;andOr&nbsp;:&nbsp;BooleanType&nbsp;boolType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;andOr.left&nbsp;:&nbsp;boolType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;andOr.right&nbsp;:&nbsp;boolType<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;ArithmeticSigned<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;ArithmeticSigned&nbsp;signed&nbsp;:&nbsp;ExpressionsFactory::eINSTANCE.createIntType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;signed.expression&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;IntType&nbsp;intType<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Now the rules for boolean negation, logical <span class="inlinecode">&amp;&amp;</span> and <span class="inlinecode">||</span> and the unary
arithmetic signed operations should be clear.
</p>
<a name="ExpressionsInfer"></a>
<h3>Type Inference for Variables</h3>
<p>
We need one more rule for typing expressions, in particular the one
for <span class="inlinecode">VariableReference</span>, whose type is the type of the referred variable.
But what is the type of a variable?  The idea is that we infer the type of
a variable from the type of its expression.
</p>
<p>
Since <span class="inlinecode">Variable</span> is not an <span class="inlinecode">Expression</span> in our grammar, we need
to introduce another judgment in our type system (an alternative would have
been to introduce in the grammar a rule introducing a common superclass
for both <span class="inlinecode">Variable</span> and <span class="inlinecode">Expression</span>, e.g., <span class="inlinecode">Typable</span>, 
and write the <span class="inlinecode">type</span> judgment with the first parameter of type <span class="inlinecode">Typable</span>).
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">judgments</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<span class="comment">//&nbsp;as&nbsp;above...<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;vartype&nbsp;||-&nbsp;Variable&nbsp;variable&nbsp;:&nbsp;<span class="keyword">output</span>&nbsp;Type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"cannot&nbsp;type&nbsp;"</span>&nbsp;+&nbsp;stringRep(variable)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;variable<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">feature</span>&nbsp;ExpressionsPackage::eINSTANCE.variable_Expression<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Note that the new judgment has a different symbol w.r.t. the <span class="inlinecode">type</span>
judgment.  Moreover, when specifying the error for such judgments
we specify that the EObject for the error marker is the variable,
but the feature for the error marker is the variable&apos;s expression.
This will generate a better error marker.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;VariableReference<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;VariableReference&nbsp;varRef&nbsp;:&nbsp;Type&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;||-&nbsp;varRef.ref&nbsp;:&nbsp;type<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;Variable<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;||-&nbsp;Variable&nbsp;variable&nbsp;:&nbsp;Type&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;variable.expression&nbsp;!=&nbsp;<span class="keyword">null</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;variable.expression&nbsp;:&nbsp;type<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Now, the type rule for <span class="inlinecode">VariableReference</span> relies on the judgment
<span class="inlinecode">vartype</span>, which states that the type of a variable is the type
of its expression.
</p>
<p>
IMPORTANT: note that expressions can refer to other variables, and in
case of mutual dependencies like
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
i&nbsp;=&nbsp;j&nbsp;+&nbsp;10<br/>
j&nbsp;=&nbsp;i&nbsp;*5<br/>
</p>
</div>
</div>
</p>
<p>
the typing would enter an infinite loop!  For this reason, for this example
language we limited the scope of variables: expressions can refer only
to variables defined before the current expression.
</p>
<a name="ExpressionsValidation"></a>
<h2>Expressions Validation</h2>
<p>
Now that we have our type system for expressions we can write
validation rules (<a href="XsemanticsSyntax.html#CheckRules" title="Go to &quot;Rules for Validator: checkrule&quot;" >section CheckRules</a>):
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">checkrule</span>&nbsp;CheckVariable&nbsp;<span class="keyword">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Variable&nbsp;variable<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;||-&nbsp;variable&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;type<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
This simply checks that we can give a <span class="inlinecode">Variable</span> a type
(in an empty environment).
</p>
<p>
Please refer to <a href="XsemanticsSyntax.html#GeneratedValidator" title="Go to &quot;The Generated Java Validator&quot;" >section GeneratedValidator</a>, in particular,
<a href="XsemanticsSyntax.html#validatorExtends" title="Go to &quot;The validatorExtends clause&quot;" >section validatorExtends</a>, to see how to use the generated
Java validator (which we also followed in the implementation of this
Expressions example language).
</p>
<a name="ExpressionsInterpreter"></a>
<h2>Interpreter for Expressions</h2>
<p>
Xsemantics can be used also to write interpreter rules (which can be
seen also as the operational semantics of the language).
</p>
<p>
For the Expressions language we thus introduce another judgment kind:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">judgments</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<span class="comment">//&nbsp;as&nbsp;above...<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;interpret&nbsp;|-&nbsp;Expression&nbsp;expression&nbsp;~&gt;&nbsp;<span class="keyword">output</span>&nbsp;Object<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Note that we assume that we will run the interpreter ONLY on well-typed
Expressions program.
</p>
<p>
We then start writing the rules for this new judgment
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">axiom</span>&nbsp;InterpretNumberLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;NumberLiteral&nbsp;number&nbsp;~&gt;&nbsp;number.value<br/>
<br/>
<span class="keyword">axiom</span>&nbsp;InterpretStringLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;StringLiteral&nbsp;string&nbsp;~&gt;&nbsp;string.value<br/>
<br/>
<span class="keyword">axiom</span>&nbsp;InterpretBooleanLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;BooleanLiteral&nbsp;bool&nbsp;~&gt;&nbsp;Boolean::valueOf(bool.value)<br/>
</p>
</div>
</div>
</p>
<p>
The rules for literals are pretty straightforward; note only the case for
boolean literals: since the <span class="inlinecode">value</span> feature is a string, we need to
convert it to an actual boolean.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;InterpretMinus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Minus&nbsp;plus&nbsp;~&gt;&nbsp;Integer&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.intValue&nbsp;-&nbsp;rightResult.intValue<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretMultiOrDiv<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;MultiOrDiv&nbsp;multiOrDiv&nbsp;~&gt;&nbsp;Integer&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;multiOrDiv.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;multiOrDiv.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(multiOrDiv.op&nbsp;==&nbsp;<span class="string">&apos;*&apos;</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.intValue&nbsp;*&nbsp;rightResult.intValue<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.intValue&nbsp;/&nbsp;rightResult.intValue<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretArithmeticSigned<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;ArithmeticSigned&nbsp;signed&nbsp;~&gt;&nbsp;Integer&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;signed.expression&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;expResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-(expResult)<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The above rules rely on the fact that the result of subexpression is
an <span class="inlinecode">Integer</span>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;InterpretAndOr<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;AndOrExpression&nbsp;andOr&nbsp;~&gt;&nbsp;Boolean&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;andOr.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Boolean&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;andOr.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Boolean&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(andOr.op&nbsp;==&nbsp;<span class="string">"&amp;&amp;"</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.booleanValue&nbsp;&amp;&amp;&nbsp;rightResult.booleanValue<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.booleanValue&nbsp;||&nbsp;rightResult.booleanValue<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretBooleanNegation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;BooleanNegation&nbsp;neg&nbsp;~&gt;&nbsp;Boolean&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;neg.expression&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Boolean&nbsp;expResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;!expResult<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Similarly in case of boolean expressions the result of subexpressions is
assumed to be a <span class="inlinecode">Boolean</span>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;InterpretComparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Comparison&nbsp;comparison&nbsp;~&gt;&nbsp;Boolean&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;|-&nbsp;comparison.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;|-&nbsp;comparison.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(leftResult&nbsp;<span class="keyword">instanceof</span>&nbsp;String&nbsp;&amp;&amp;&nbsp;rightResult&nbsp;<span class="keyword">instanceof</span>&nbsp;String)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.toString&nbsp;&lt;&nbsp;rightResult.toString<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;both&nbsp;are&nbsp;int&nbsp;if&nbsp;the&nbsp;expression&nbsp;is&nbsp;well-typed<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;(leftResult&nbsp;<span class="keyword">as</span>&nbsp;Integer)&nbsp;&lt;&nbsp;(rightResult&nbsp;<span class="keyword">as</span>&nbsp;Integer)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretEquals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Equals&nbsp;comparison&nbsp;~&gt;&nbsp;Boolean&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;|-&nbsp;comparison.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;|-&nbsp;comparison.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.toString&nbsp;==&nbsp;rightResult.toString<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
For comparison, the result will be a <span class="inlinecode">Boolean</span>; note that we check
whether the subexpressions are strings to convert them to a string representation
and compare such representation; the only other possible case is that they are
both integer (remember that we will call the interpreter only on well-typed
programs).  Note that for equality we simply convert the result of
subexpressions to string and compare the resulting string representation.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;InterpretPlus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Plus&nbsp;plus&nbsp;~&gt;&nbsp;Object&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(leftResult&nbsp;<span class="keyword">instanceof</span>&nbsp;String&nbsp;||&nbsp;rightResult&nbsp;<span class="keyword">instanceof</span>&nbsp;String)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;leftString&nbsp;=&nbsp;leftResult.toString<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;rightString&nbsp;=&nbsp;rightResult.toString<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftString&nbsp;+&nbsp;rightString<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;both&nbsp;are&nbsp;int&nbsp;if&nbsp;the&nbsp;expression&nbsp;is&nbsp;well-typed<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;leftInt&nbsp;=&nbsp;leftResult&nbsp;<span class="keyword">as</span>&nbsp;Integer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;rightInt&nbsp;=&nbsp;rightResult&nbsp;<span class="keyword">as</span>&nbsp;Integer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftInt&nbsp;+&nbsp;rightInt<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretVariableRefenrence<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;VariableReference&nbsp;varRef&nbsp;~&gt;&nbsp;Object&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;varRef.ref.expression&nbsp;~&gt;&nbsp;result<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
At this point, the remaining above interpreter rules should be
straightforward.
</p>
<a name="ExpressionsCustomization"></a>
<h2>Customizations for Expressions</h2>
<p>
For the Expressions language we provide a custom implementation of
<abbr title="it.xsemantics.runtime.StringRepresentation" >StringRepresentation</abbr> (see also
<a href="XsemanticsSyntax.html#StringRepresentation" title="Go to &quot;String Representation&quot;" >section StringRepresentation</a>):
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;ExpressionsStringRepresentation&nbsp;<span class="keyword">extends</span>&nbsp;StringRepresentation&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">protected</span>&nbsp;String&nbsp;stringRep(String&nbsp;s)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="string">"&apos;"</span>&nbsp;+&nbsp;s&nbsp;+&nbsp;<span class="string">"&apos;"</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
This way when a <a class="jdoc" href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html" title="View JavaDoc"><abbr title="java.lang.String" >String</abbr></a> has to be represented by Xsemantics
generated code, it will add quotes around it; this way we are sure that we
are dealing with an actual string.
</p>
<p>
Of course, we provide the guice binding for this:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;ExpressionsRuntimeModule&nbsp;<span class="keyword">extends</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it.xsemantics.example.expressions.AbstractExpressionsRuntimeModule&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;Class&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;StringRepresentation&gt;&nbsp;bindStringRepresentation()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;ExpressionsStringRepresentation.<span class="keyword">class</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
...<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="MoreInvolvedExpressionsSystem"></a>
<h2>A more involved Expressions System</h2>
<p>
Now, let&apos;s complicate things a bit, and make the system for our
Expressions language more powerful, with this new requirement:
we want to be able to implicitly convert string literals to numbers
and booleans when this is possible.  This way, if an expression requires
the subexpressions to be numbers or booleans we can also accept string literals
if they can be convertible.  
(Note that we intentionally avoided to consider the number literal
<span class="inlinecode">0</span> as <span class="inlinecode">false</span> and a number literal different from <span class="inlinecode">0</span>
as <span class="inlinecode">true</span>, but you can extend the system further if you want).
Thus, we want the following expressions to be
valid (and interpreted accordingly with an implicit conversion):
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
i&nbsp;=&nbsp;20&nbsp;-&nbsp;<span class="string">&apos;5&apos;</span>&nbsp;<span class="comment">//&nbsp;OK!&nbsp;can&nbsp;be&nbsp;given&nbsp;int&nbsp;type&nbsp;and&nbsp;evaluates&nbsp;to&nbsp;15<br/>
</span>b&nbsp;=&nbsp;(i&nbsp;&gt;&nbsp;20)&nbsp;||&nbsp;<span class="string">&apos;true&apos;</span>&nbsp;<span class="comment">//&nbsp;OK!&nbsp;can&nbsp;be&nbsp;given&nbsp;boolean&nbsp;type<br/>
</span><span class="comment">//&nbsp;and&nbsp;evaluates&nbsp;to&nbsp;true&nbsp;<br/>
</span>
</p>
</div>
</div>
</p>
<p>
Note that in case no expectation on types is expressed, the system
will be behave as before:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
i&nbsp;=&nbsp;20&nbsp;+&nbsp;<span class="string">&apos;5&apos;</span>&nbsp;<span class="comment">//&nbsp;has&nbsp;string&nbsp;type&nbsp;and&nbsp;evaluates&nbsp;to&nbsp;&apos;205&apos;<br/>
</span>j&nbsp;=&nbsp;(20&nbsp;*&nbsp;1)&nbsp;+&nbsp;<span class="string">&apos;5&apos;</span>&nbsp;<span class="comment">//&nbsp;has&nbsp;string&nbsp;type&nbsp;again<br/>
</span>k&nbsp;=&nbsp;20&nbsp;*&nbsp;(1&nbsp;+&nbsp;<span class="string">&apos;5&apos;</span>)&nbsp;<span class="comment">//&nbsp;has&nbsp;int&nbsp;type,&nbsp;since&nbsp;*&nbsp;requires&nbsp;int&nbsp;types<br/>
</span><span class="comment">//&nbsp;on&nbsp;subexpressions<br/>
</span>
</p>
</div>
</div>
</p>
<p>
Since this more involved system will have most rules in common with
the first system we presented, we will write this new system as
an extended system (<a href="XsemanticsSyntax.html#SystemExtension" title="Go to &quot;Extend another System&quot;" >section SystemExtension</a>), starting from the previous one:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">system</span>&nbsp;<span class="keyword">it</span>.xsemantics.example.expressions.typing.ExtendedExpressionsSemantics<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">extends</span>&nbsp;<span class="keyword">it</span>.xsemantics.example.expressions.typing.ExpressionsSemantics<br/>
</p>
</div>
</div>
</p>
<p>
Thus, we introduce a new judgment in our system (the other ones are simply
inherited from the super system):
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">judgments</span>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;coerce&nbsp;|~&nbsp;Expression&nbsp;expression&nbsp;|&gt;&nbsp;Type&nbsp;expectedType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"cannot&nbsp;convert&nbsp;"</span>&nbsp;+&nbsp;stringRep(expression)&nbsp;+<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"&nbsp;to&nbsp;type&nbsp;"</span>&nbsp;+&nbsp;stringRep(expectedType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;expression<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
We then have to define the rules for this new judgment:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;StringToInt<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;StringLiteral&nbsp;string&nbsp;|&gt;&nbsp;IntType&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Integer::parseInt(string.value)<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;StringToBool<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;StringLiteral&nbsp;string&nbsp;|&gt;&nbsp;BooleanType&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;string.value.equalsIgnoreCase(<span class="string">"true"</span>)&nbsp;||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;string.value.equalsIgnoreCase(<span class="string">"false"</span>)<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Then, this judgment will be used by the other rules; in particular, we need to
modify some rules we have seen so far.
</p>
<p>
The idea is that, as hinted above, that rules that expect a subexpression to
be of a specific type should "communicate" this expectation through the
rule environment (refer to <a href="XsemanticsSyntax.html#Environment" title="Go to &quot;Rule Environment&quot;" >section Environment</a>), by mapping the string
<span class="inlinecode"><span class="string">&apos;expected&apos;</span></span> to the expected type.
</p>
<p>
We will need then to override some rules of the previous system:
the rule for <span class="inlinecode">StringLiteral</span>, since its
type now depends on the above expectation:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">override</span>&nbsp;<span class="keyword">rule</span>&nbsp;StringLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;StringLiteral&nbsp;str&nbsp;:&nbsp;Type&nbsp;resultType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;expected&nbsp;=&nbsp;<span class="keyword">env</span>(G,&nbsp;<span class="string">&apos;expected&apos;</span>,&nbsp;Type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;str&nbsp;|&gt;&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultType&nbsp;=&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultType&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createStringType<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The first block of the <span class="inlinecode">or</span> can fail due to the fact that
</p>
<p>
<ul>
	<li>
		No expectation was requested or
	</li>
	<li>
		the expectation cannot be satisfied
	</li>
</ul>
</p>
<p>
In any other case the type will be <span class="inlinecode">string</span> (which might make invoking
rules fail).
</p>
<p>
Now we need to override those rules that have expectations on subexpressions,
in order to pass to rule invocation an appropriate environment:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">override</span>&nbsp;<span class="keyword">rule</span>&nbsp;MultiOrDiv<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;MultiOrDiv&nbsp;multiOrDiv&nbsp;:&nbsp;IntType&nbsp;intType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intType&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createIntType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;intType&nbsp;|-&nbsp;multiOrDiv.left&nbsp;:&nbsp;intType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;intType&nbsp;|-&nbsp;multiOrDiv.right&nbsp;:&nbsp;intType<br/>
}<br/>
<br/>
<span class="keyword">override</span>&nbsp;<span class="keyword">rule</span>&nbsp;AndOr<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;AndOrExpression&nbsp;andOr&nbsp;:&nbsp;BooleanType&nbsp;boolType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolType&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createBooleanType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;boolType&nbsp;|-&nbsp;andOr.left&nbsp;:&nbsp;boolType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;boolType&nbsp;|-&nbsp;andOr.right&nbsp;:&nbsp;boolType<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
We only showed two examples (the other rules for expected int and boolean
types are updated accordingly).
</p>
<p>
Note that in cases where no expectation is required, we now need to
pass an empty environment when typing subexpressions, otherwise we might
reject well-typed expressions due to expectations that were passed to the
current rule upon invocation.  This however was already implemented
in the super system, so we don&apos;t need to override those rules.
</p>
<p>
The rule for Plus now is a little bit more complex, since it
has to take care of possible expectations:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">override</span>&nbsp;<span class="keyword">rule</span>&nbsp;Plus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Plus&nbsp;plus&nbsp;:&nbsp;Type&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.left&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;leftType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.right&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;TyThe&nbsp;-e&nbsp;option&nbsp;is&nbsp;not&nbsp;standard.&nbsp;A&nbsp;POSIX-compliant&nbsp;echo&nbsp;does&nbsp;not&nbsp;accept&nbsp;any&nbsp;options:pe&nbsp;rightType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;expected&nbsp;=&nbsp;<span class="keyword">env</span>(G,&nbsp;<span class="string">&apos;expected&apos;</span>,&nbsp;Type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;plus.left&nbsp;|&gt;&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;plus.right&nbsp;|&gt;&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType&nbsp;||&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createStringType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType&nbsp;&amp;&amp;&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;leftType&nbsp;<span class="comment">//&nbsp;i.e.,&nbsp;IntType<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Now we need to adapt also some interpretation rules to take into
consideration expectations:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">override</span>&nbsp;<span class="keyword">rule</span>&nbsp;InterpretStringLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;StringLiteral&nbsp;string&nbsp;~&gt;&nbsp;Object&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=&nbsp;<span class="keyword">env</span>(G,&nbsp;<span class="string">&apos;expected&apos;</span>,&nbsp;IntType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;Integer::parseInt(string.value)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=&nbsp;<span class="keyword">env</span>(G,&nbsp;<span class="string">&apos;expected&apos;</span>,&nbsp;BooleanType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;Boolean::parseBoolean(string.value)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;string.value<br/>
}<br/>
<br/>
<span class="keyword">override</span>&nbsp;<span class="keyword">rule</span>&nbsp;InterpretMultiOrDiv<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;MultiOrDiv&nbsp;multiOrDiv&nbsp;~&gt;&nbsp;Integer&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;IntType&nbsp;intType&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createIntType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;intType&nbsp;|-&nbsp;multiOrDiv.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;intType&nbsp;|-&nbsp;multiOrDiv.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(multiOrDiv.op&nbsp;==&nbsp;<span class="string">&apos;*&apos;</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.intValue&nbsp;*&nbsp;rightResult.intValue<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.intValue&nbsp;/&nbsp;rightResult.intValue<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Again, we only showed some modified rules; now it should be clear what
other rules need to be adapted and how.
</p>
<p>
All the other rules which do not require adaption will be simply
inherited from the super system.
</p>
<a name="ExpressionsCodeGeneration"></a>
<h2>Generation for Expressions</h2>
<p>
The Expressions language we used in this example does not implement any
real code generation.  However, we implemented a generation strategy just
for the sake of demonstration on how to use the generated Java code
and the trace utilities.
</p>
<p>
The generator will generate an <span class="inlinecode">.output</span> file which shows
the type for each variable, the interpretation of its expression, together
with the application traces (as strings) both for the type and the interpretation.
The relevant part of the generator (written in Xtend2) is shown:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;ExpressionsGenerator&nbsp;<span class="keyword">implements</span>&nbsp;IGenerator&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject&nbsp;ExpressionsSemantics&nbsp;semantics<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;TraceUtils<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;StringRepresentation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;skipped&nbsp;some&nbsp;code<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;compileExpression(Expression&nbsp;exp)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;typeTrace&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;RuleApplicationTrace()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;interpreterTrace&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;RuleApplicationTrace()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;type&nbsp;=&nbsp;semantics.type(null,&nbsp;typeTrace,&nbsp;exp)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;result&nbsp;=&nbsp;semantics.interpret(null,&nbsp;interpreterTrace,&nbsp;exp)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;&apos;&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&laquo;</span>type.value.string<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;trace:&nbsp;&laquo;</span>typeTrace.traceAsString<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interpretation:&nbsp;&laquo;</span>result.value.string<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interpretation&nbsp;trace:&nbsp;&laquo;</span>interpreterTrace.traceAsString<span class="string">&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&apos;&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
<span class="inlinecode">ExpressionsSemantics</span> is the Java class generated by Xsemantics from
the system we wrote for the Expressions language.
</p>
<p>
Actually, we want to use the extended system (<a href="Expressions-example.html#MoreInvolvedExpressionsSystem" title="Go to &quot;A more involved Expressions System&quot;" >section MoreInvolvedExpressionsSystem</a>),
thus we will bind <span class="inlinecode">ExpressionsSemantics</span> to <span class="inlinecode">ExtendedExpressionsSemantics</span>
in the runtime module:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;ExpressionsRuntimeModule&nbsp;<span class="keyword">extends</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it.xsemantics.example.expressions.AbstractExpressionsRuntimeModule&nbsp;{<br/>
...<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;Class&lt;?&nbsp;<span class="keyword">extends</span>&nbsp;ExpressionsSemantics&gt;&nbsp;bindExpressionsSemantics()&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;ExtendedExpressionsSemantics.<span class="keyword">class</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Note that <span class="inlinecode">string</span> and <span class="inlinecode">traceAsString</span> come from
<abbr title="it.xsemantics.runtime.StringRepresentation" >StringRepresentation</abbr> and
<abbr title="it.xsemantics.runtime.TraceUtils" >TraceUtils</abbr> respectively, and they
are used as extension methods.
</p>
<p>
Thus, starting from this expression:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myString&nbsp;=&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;+&nbsp;10&nbsp;+&nbsp;false<br/>
</p>
</div>
</div>
</p>
<p>
we get this output:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Variable:&nbsp;myString<br/>
type:&nbsp;StringType<br/>
type&nbsp;trace:&nbsp;<br/>
Plus:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;+&nbsp;10&nbsp;+&nbsp;false&nbsp;:&nbsp;StringType<br/>
&nbsp;Plus:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;+&nbsp;10&nbsp;:&nbsp;StringType<br/>
&nbsp;&nbsp;StringLiteral:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;:&nbsp;StringType<br/>
&nbsp;&nbsp;NumeralLiteral:&nbsp;[]&nbsp;|-&nbsp;10&nbsp;:&nbsp;IntType<br/>
&nbsp;BooleanLiteral:&nbsp;[]&nbsp;|-&nbsp;false&nbsp;:&nbsp;BooleanType<br/>
<br/>
interpretation:&nbsp;<span class="string">&apos;foo10false&apos;</span><br/>
interpretation&nbsp;trace:&nbsp;<br/>
InterpretPlus:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;+&nbsp;10&nbsp;+&nbsp;false&nbsp;~&gt;&nbsp;<span class="string">&apos;foo10false&apos;</span><br/>
&nbsp;InterpretPlus:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;+&nbsp;10&nbsp;~&gt;&nbsp;<span class="string">&apos;foo10&apos;</span><br/>
&nbsp;&nbsp;InterpretStringLiteral:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;~&gt;&nbsp;<span class="string">&apos;foo&apos;</span><br/>
&nbsp;&nbsp;InterpretNumberLiteral:&nbsp;[]&nbsp;|-&nbsp;10&nbsp;~&gt;&nbsp;10<br/>
&nbsp;InterpretBooleanLiteral:&nbsp;[]&nbsp;|-&nbsp;false&nbsp;~&gt;&nbsp;false<br/>
</p>
</div>
</div>
</p>
<p>
Note that the indentation represents the stack of invoked rules.
The quotes around string literals come from our customization of
<abbr title="it.xsemantics.runtime.StringRepresentation" >StringRepresentation</abbr>, see <a href="Expressions-example.html#ExpressionsCustomization" title="Go to &quot;Customizations for Expressions&quot;" >section ExpressionsCustomization</a>.
Moreover <span class="inlinecode">[]</span> represents an empty environment.
</p>
<p>
A more involved example including variable references and
implicit coercions is
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
intVar&nbsp;=&nbsp;1<br/>
intVar2&nbsp;=&nbsp;2&nbsp;*&nbsp;(intVar&nbsp;+&nbsp;<span class="string">&apos;1&apos;</span>)<br/>
</p>
</div>
</div>
</p>
<p>
which produces the following output
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Variable:&nbsp;intVar2<br/>
type:&nbsp;IntType<br/>
type&nbsp;trace:&nbsp;<br/>
MultiOrDiv:&nbsp;[]&nbsp;|-&nbsp;2&nbsp;*&nbsp;(intVar&nbsp;+&nbsp;<span class="string">&apos;1&apos;</span>)&nbsp;:&nbsp;IntType<br/>
&nbsp;NumeralLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;2&nbsp;:&nbsp;IntType<br/>
&nbsp;Plus:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;intVar&nbsp;+&nbsp;<span class="string">&apos;1&apos;</span>&nbsp;:&nbsp;IntType<br/>
&nbsp;&nbsp;VariableReference:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;intVar&nbsp;:&nbsp;IntType<br/>
&nbsp;&nbsp;&nbsp;Variable:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;||-&nbsp;intVar&nbsp;=&nbsp;1&nbsp;:&nbsp;IntType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;NumeralLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;1&nbsp;:&nbsp;IntType<br/>
&nbsp;&nbsp;StringLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;<span class="string">&apos;1&apos;</span>&nbsp;:&nbsp;IntType<br/>
&nbsp;&nbsp;&nbsp;StringToInt:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|~&nbsp;<span class="string">&apos;1&apos;</span>&nbsp;|&gt;&nbsp;IntType<br/>
<br/>
interpretation:&nbsp;4<br/>
interpretation&nbsp;trace:&nbsp;<br/>
InterpretMultiOrDiv:&nbsp;[]&nbsp;|-&nbsp;2&nbsp;*&nbsp;(intVar&nbsp;+&nbsp;<span class="string">&apos;1&apos;</span>)&nbsp;~&gt;&nbsp;4<br/>
&nbsp;InterpretNumberLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;2&nbsp;~&gt;&nbsp;2<br/>
&nbsp;InterpretPlus:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;intVar&nbsp;+&nbsp;<span class="string">&apos;1&apos;</span>&nbsp;~&gt;&nbsp;2<br/>
&nbsp;&nbsp;InterpretVariableRefenrence:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;intVar&nbsp;~&gt;&nbsp;1<br/>
&nbsp;&nbsp;&nbsp;InterpretNumberLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;1&nbsp;~&gt;&nbsp;1<br/>
&nbsp;&nbsp;InterpretStringLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;<span class="string">&apos;1&apos;</span>&nbsp;~&gt;&nbsp;1<br/>
</p>
</div>
</div>
</p>
</body>
</html>
